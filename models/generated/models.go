// Code generated from UCP JSON Schemas. DO NOT EDIT.
// Source: https://github.com/Universal-Commerce-Protocol/ucp
// Generator: go-jsonschema (https://github.com/atombender/go-jsonschema)
//
// This file contains auto-generated types that match the UCP specification.
// For custom extensions and helper methods, see the parent models/ package.

// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "time"

// Append-only event that exists independently of fulfillment. Typically represents
// money movements but can be any post-order change. Polymorphic type that can
// optionally reference line items.
type Adjustment struct {
	// Amount in minor units (cents) for refunds, credits, price adjustments
	// (optional).
	Amount *int `json:"amount,omitempty"`

	// Human-readable reason or description (e.g., 'Defective item', 'Customer
	// requested').
	Description *string `json:"description,omitempty"`

	// Adjustment event identifier.
	ID string `json:"id"`

	// Which line items and quantities are affected (optional).
	LineItems []AdjustmentLineItemsElem `json:"line_items,omitempty"`

	// RFC 3339 timestamp when this adjustment occurred.
	OccurredAt time.Time `json:"occurred_at"`

	// Adjustment status.
	Status AdjustmentStatus `json:"status"`

	// Type of adjustment (open string). Typically money-related like: refund, return,
	// credit, price_adjustment, dispute, cancellation. Can be any value that makes
	// sense for the merchant's business.
	Type string `json:"type"`
}

type AdjustmentLineItemsElem struct {
	// Line item ID reference.
	ID string `json:"id"`

	// Quantity affected by this adjustment.
	Quantity int `json:"quantity"`
}

type AdjustmentStatus string

const AdjustmentStatusCompleted AdjustmentStatus = "completed"
const AdjustmentStatusFailed AdjustmentStatus = "failed"
const AdjustmentStatusPending AdjustmentStatus = "pending"

// Breakdown of how a discount amount was allocated to a specific target.
type Allocation struct {
	// Amount allocated to this target in minor (cents) currency units.
	Amount int `json:"amount"`

	// JSONPath to the allocation target (e.g., '$.line_items[0]',
	// '$.totals.shipping').
	Path string `json:"path"`
}

// The ap2 object included in checkout responses when AP2 is negotiated.
type Ap2CheckoutResponse struct {
	// Merchant's signature proving checkout terms are authentic.
	MerchantAuthorization MerchantAuthorization `json:"merchant_authorization"`
}

// The ap2 object included in complete_checkout requests when AP2 is negotiated.
type Ap2CompleteRequest struct {
	// SD-JWT+kb proving user authorized this checkout.
	CheckoutMandate CheckoutMandate `json:"checkout_mandate"`
}

// A discount that was successfully applied.
type AppliedDiscount struct {
	// Breakdown of where this discount was allocated. Sum of allocation amounts
	// equals total amount.
	Allocations []Allocation `json:"allocations,omitempty"`

	// Total discount amount in minor (cents) currency units.
	Amount int `json:"amount"`

	// True if applied automatically by merchant rules (no code required).
	Automatic bool `json:"automatic,omitempty"`

	// The discount code. Omitted for automatic discounts.
	Code *string `json:"code,omitempty"`

	// Allocation method. 'each' = applied independently per item. 'across' = split
	// proportionally by value.
	Method *AppliedDiscountMethod `json:"method,omitempty"`

	// Stacking order for discount calculation. Lower numbers applied first (1 =
	// first).
	Priority *int `json:"priority,omitempty"`

	// Human-readable discount name (e.g., 'Summer Sale 20% Off').
	Title string `json:"title"`
}

type AppliedDiscountMethod string

const AppliedDiscountMethodAcross AppliedDiscountMethod = "across"
const AppliedDiscountMethodEach AppliedDiscountMethod = "each"

type Base struct {
	// Capability-specific configuration (structure defined by each capability).
	Config map[string]interface{} `json:"config,omitempty"`

	// Parent capability this extends. Present for extensions, absent for root
	// capabilities.
	Extends *string `json:"extends,omitempty"`

	// Stable capability identifier in reverse-domain notation (e.g.,
	// dev.ucp.shopping.checkout). Used in capability negotiation.
	Name *string `json:"name,omitempty"`

	// URL to JSON Schema for this capability's payload.
	Schema *string `json:"schema,omitempty"`

	// URL to human-readable specification document.
	Spec *string `json:"spec,omitempty"`

	// Capability version in YYYY-MM-DD format.
	Version *Version `json:"version,omitempty"`
}

// Binds a token to a specific checkout session and participant. Prevents token
// reuse across different checkouts or participants.
type Binding struct {
	// The checkout session identifier this token is bound to.
	CheckoutID string `json:"checkout_id"`

	// The participant this token is bound to. Required when acting on behalf of
	// another participant (e.g., agent tokenizing for merchant). Omit when the
	// authenticated caller is the binding target.
	Identity *PaymentIdentity `json:"identity,omitempty"`
}

type Buyer struct {
	// Email of the buyer.
	Email *string `json:"email,omitempty"`

	// First name of the buyer.
	FirstName *string `json:"first_name,omitempty"`

	// Optional, buyer's full name (if first_name or last_name fields are present they
	// take precedence).
	FullName *string `json:"full_name,omitempty"`

	// Last name of the buyer.
	LastName *string `json:"last_name,omitempty"`

	// E.164 standard.
	PhoneNumber *string `json:"phone_number,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Buyer object extended with consent tracking.
type Buyer_1 interface{}

// Buyer object extended with consent tracking.
type Buyer_2 interface{}

// Buyer object extended with consent tracking.
type Buyer_3 interface{}

// A card credential containing sensitive payment card details including raw
// Primary Account Numbers (PANs). This credential type MUST NOT be used for
// checkout, only with payment handlers that tokenize or encrypt credentials.
// CRITICAL: Both parties handling CardCredential (sender and receiver) MUST be PCI
// DSS compliant. Transmission MUST use HTTPS/TLS with strong cipher suites.
type CardCredential struct {
	// The type of card number. Network tokens are preferred with fallback to FPAN.
	// See PCI Scope for more details.
	CardNumberType CardCredentialCardNumberType `json:"card_number_type"`

	// Cryptogram provided with network tokens.
	Cryptogram *string `json:"cryptogram,omitempty"`

	// Card CVC number.
	Cvc *string `json:"cvc,omitempty"`

	// Electronic Commerce Indicator / Security Level Indicator provided with network
	// tokens.
	EciValue *string `json:"eci_value,omitempty"`

	// The month of the card's expiration date (1-12).
	ExpiryMonth *int `json:"expiry_month,omitempty"`

	// The year of the card's expiration date.
	ExpiryYear *int `json:"expiry_year,omitempty"`

	// Cardholder name.
	Name *string `json:"name,omitempty"`

	// Card number.
	Number *string `json:"number,omitempty"`

	// The credential type identifier for card credentials.
	Type interface{} `json:"type"`
}

type CardCredentialCardNumberType string

const CardCredentialCardNumberTypeDpan CardCredentialCardNumberType = "dpan"
const CardCredentialCardNumberTypeFpan CardCredentialCardNumberType = "fpan"
const CardCredentialCardNumberTypeNetworkToken CardCredentialCardNumberType = "network_token"

// Checkout extended with consent tracking via buyer object.
type Checkout interface{}

// Base checkout schema. Extensions compose onto this using allOf.
type CheckoutCreateRequest struct {
	// Representation of the buyer.
	Buyer *Buyer `json:"buyer,omitempty"`

	// ISO 4217 currency code.
	Currency string `json:"currency"`

	// List of line items being checked out.
	LineItems []LineItemCreateRequest `json:"line_items"`

	// Payment corresponds to the JSON schema field "payment".
	Payment PaymentCreateRequest `json:"payment"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// SD-JWT+kb credential in `ap2.checkout_mandate`. Proving user authorization for
// the checkout. Contains the full checkout including `ap2.merchant_authorization`.
type CheckoutMandate string

// Base checkout schema. Extensions compose onto this using allOf.
type CheckoutResponse struct {
	// Representation of the buyer.
	Buyer *Buyer `json:"buyer,omitempty"`

	// URL for checkout handoff and session recovery. MUST be provided when status is
	// requires_escalation. See specification for format and availability
	// requirements.
	ContinueURL *string `json:"continue_url,omitempty"`

	// ISO 4217 currency code.
	Currency string `json:"currency"`

	// RFC 3339 expiry timestamp. Default TTL is 6 hours from creation if not sent.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Unique identifier of the checkout session.
	ID string `json:"id"`

	// List of line items being checked out.
	LineItems []LineItemResponse `json:"line_items"`

	// Links to be displayed by the platform (Privacy Policy, TOS). Mandatory for
	// legal compliance.
	Links []Link `json:"links"`

	// List of messages with error and info about the checkout session state.
	Messages []map[string]interface{} `json:"messages,omitempty"`

	// Details about an order created for this checkout session.
	Order *OrderConfirmation `json:"order,omitempty"`

	// Payment corresponds to the JSON schema field "payment".
	Payment PaymentResponse `json:"payment"`

	// Checkout state indicating the current phase and required action. See Checkout
	// Status lifecycle documentation for state transition details.
	Status CheckoutResponseStatus `json:"status"`

	// Different cart totals.
	Totals []TotalResponse `json:"totals"`

	// Ucp corresponds to the JSON schema field "ucp".
	Ucp ResponseCheckout `json:"ucp"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type CheckoutResponseStatus string

const CheckoutResponseStatusCanceled CheckoutResponseStatus = "canceled"
const CheckoutResponseStatusCompleteInProgress CheckoutResponseStatus = "complete_in_progress"
const CheckoutResponseStatusCompleted CheckoutResponseStatus = "completed"
const CheckoutResponseStatusIncomplete CheckoutResponseStatus = "incomplete"
const CheckoutResponseStatusReadyForComplete CheckoutResponseStatus = "ready_for_complete"
const CheckoutResponseStatusRequiresEscalation CheckoutResponseStatus = "requires_escalation"

// Checkout extended with AP2 embedded signature support.
type CheckoutResponseWithAp2 interface{}

// Base checkout schema. Extensions compose onto this using allOf.
type CheckoutUpdateRequest struct {
	// Representation of the buyer.
	Buyer *Buyer `json:"buyer,omitempty"`

	// ISO 4217 currency code.
	Currency string `json:"currency"`

	// Unique identifier of the checkout session.
	ID string `json:"id"`

	// List of line items being checked out.
	LineItems []LineItemUpdateRequest `json:"line_items"`

	// Payment corresponds to the JSON schema field "payment".
	Payment PaymentUpdateRequest `json:"payment"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Checkout extended with consent tracking via buyer object.
type Checkout_1 interface{}

// Checkout extended with consent tracking via buyer object.
type Checkout_2 interface{}

// Checkout extended with discount capability.
type Checkout_3 interface{}

// Checkout extended with discount capability.
type Checkout_4 interface{}

// Checkout extended with discount capability.
type Checkout_5 interface{}

// Checkout extended with hierarchical fulfillment.
type Checkout_6 interface{}

// Checkout extended with hierarchical fulfillment.
type Checkout_7 interface{}

// Checkout extended with hierarchical fulfillment.
type Checkout_8 interface{}

// Extension fields for complete_checkout when AP2 is negotiated.
type CompleteRequestWithAp2 struct {
	// AP2 extension data including checkout mandate.
	Ap2 *Ap2CompleteRequest `json:"ap2,omitempty"`
}

// User consent states for data processing
type Consent struct {
	// Consent for analytics and performance tracking.
	Analytics *bool `json:"analytics,omitempty"`

	// Consent for marketing communications.
	Marketing *bool `json:"marketing,omitempty"`

	// Consent for storing user preferences.
	Preferences *bool `json:"preferences,omitempty"`

	// Consent for selling data to third parties (CCPA).
	SaleOfData *bool `json:"sale_of_data,omitempty"`
}

// Discount codes input and applied discounts output.
type DiscountsObject struct {
	// Discounts successfully applied (code-based and automatic).
	Applied []AppliedDiscount `json:"applied,omitempty"`

	// Discount codes to apply. Case-insensitive. Replaces previously submitted codes.
	// Send empty array to clear.
	Codes []string `json:"codes,omitempty"`
}

// Full capability declaration for discovery profiles. Includes spec/schema URLs
// for agent fetching.
type Discovery interface{}

// Full UCP metadata for /.well-known/ucp discovery.
type DiscoveryProfile struct {
	// Supported capabilities and extensions.
	Capabilities []DiscoveryProfileCapabilitiesElem `json:"capabilities"`

	// Services corresponds to the JSON schema field "services".
	Services map[string]UCPService `json:"services"`

	// Version corresponds to the JSON schema field "version".
	Version Version `json:"version"`
}

type DiscoveryProfileCapabilitiesElem interface{}

type ErrorCode string

const ErrorCodeAgentMissingKey ErrorCode = "agent_missing_key"
const ErrorCodeMandateExpired ErrorCode = "mandate_expired"
const ErrorCodeMandateInvalidSignature ErrorCode = "mandate_invalid_signature"
const ErrorCodeMandateRequired ErrorCode = "mandate_required"
const ErrorCodeMandateScopeMismatch ErrorCode = "mandate_scope_mismatch"
const ErrorCodeMerchantAuthorizationInvalid ErrorCode = "merchant_authorization_invalid"
const ErrorCodeMerchantAuthorizationMissing ErrorCode = "merchant_authorization_missing"

// Buyer-facing fulfillment expectation representing logical groupings of items
// (e.g., 'package'). Can be split, merged, or adjusted post-order to set buyer
// expectations for when/how items arrive.
type Expectation struct {
	// Human-readable delivery description (e.g., 'Arrives in 5-8 business days').
	Description *string `json:"description,omitempty"`

	// Delivery destination address.
	Destination PostalAddress `json:"destination"`

	// When this expectation can be fulfilled: 'now' or ISO 8601 timestamp for future
	// date (backorder, pre-order).
	FulfillableOn *string `json:"fulfillable_on,omitempty"`

	// Expectation identifier.
	ID string `json:"id"`

	// Which line items and quantities are in this expectation.
	LineItems []ExpectationLineItemsElem `json:"line_items"`

	// Delivery method type (shipping, pickup, digital).
	MethodType ExpectationMethodType `json:"method_type"`
}

type ExpectationLineItemsElem struct {
	// Line item ID reference.
	ID string `json:"id"`

	// Quantity of this item in this expectation.
	Quantity int `json:"quantity"`
}

type ExpectationMethodType string

const ExpectationMethodTypeDigital ExpectationMethodType = "digital"
const ExpectationMethodTypePickup ExpectationMethodType = "pickup"
const ExpectationMethodTypeShipping ExpectationMethodType = "shipping"

// Inventory availability hint for a fulfillment method type.
type FulfillmentAvailableMethodResponse struct {
	// Human-readable availability info (e.g., 'Available for pickup at Downtown Store
	// today').
	Description *string `json:"description,omitempty"`

	// 'now' for immediate availability, or ISO 8601 date for future (preorders,
	// transfers).
	FulfillableOn *string `json:"fulfillable_on,omitempty"`

	// Line items available for this fulfillment method.
	LineItemIds []string `json:"line_item_ids"`

	// Fulfillment method type this availability applies to.
	Type FulfillmentAvailableMethodResponseType `json:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type FulfillmentAvailableMethodResponseType string

const FulfillmentAvailableMethodResponseTypePickup FulfillmentAvailableMethodResponseType = "pickup"
const FulfillmentAvailableMethodResponseTypeShipping FulfillmentAvailableMethodResponseType = "shipping"

// Append-only fulfillment event representing an actual shipment. References line
// items by ID.
type FulfillmentEvent struct {
	// Carrier name (e.g., 'FedEx', 'USPS').
	Carrier *string `json:"carrier,omitempty"`

	// Human-readable description of the shipment status or delivery information
	// (e.g., 'Delivered to front door', 'Out for delivery').
	Description *string `json:"description,omitempty"`

	// Fulfillment event identifier.
	ID string `json:"id"`

	// Which line items and quantities are fulfilled in this event.
	LineItems []FulfillmentEventLineItemsElem `json:"line_items"`

	// RFC 3339 timestamp when this fulfillment event occurred.
	OccurredAt time.Time `json:"occurred_at"`

	// Carrier tracking number (required if type != processing).
	TrackingNumber *string `json:"tracking_number,omitempty"`

	// URL to track this shipment (required if type != processing).
	TrackingURL *string `json:"tracking_url,omitempty"`

	// Fulfillment event type. Common values include: processing (preparing to ship),
	// shipped (handed to carrier), in_transit (in delivery network), delivered
	// (received by buyer), failed_attempt (delivery attempt failed), canceled
	// (fulfillment canceled), undeliverable (cannot be delivered), returned_to_sender
	// (returned to merchant).
	Type string `json:"type"`
}

type FulfillmentEventLineItemsElem struct {
	// Line item ID reference.
	ID string `json:"id"`

	// Quantity fulfilled in this event.
	Quantity int `json:"quantity"`
}

// A merchant-generated package/group of line items with fulfillment options.
type FulfillmentGroupCreateRequest struct {
	// ID of the selected fulfillment option for this group.
	SelectedOptionID *string `json:"selected_option_id,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A merchant-generated package/group of line items with fulfillment options.
type FulfillmentGroupResponse struct {
	// Group identifier for referencing merchant-generated groups in updates.
	ID string `json:"id"`

	// Line item IDs included in this group/package.
	LineItemIds []string `json:"line_item_ids"`

	// Available fulfillment options for this group.
	Options []FulfillmentOptionResponse `json:"options,omitempty"`

	// ID of the selected fulfillment option for this group.
	SelectedOptionID *string `json:"selected_option_id,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A merchant-generated package/group of line items with fulfillment options.
type FulfillmentGroupUpdateRequest struct {
	// Group identifier for referencing merchant-generated groups in updates.
	ID string `json:"id"`

	// ID of the selected fulfillment option for this group.
	SelectedOptionID *string `json:"selected_option_id,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A fulfillment method (shipping or pickup) with destinations and groups.
type FulfillmentMethodCreateRequest struct {
	// Available destinations. For shipping: addresses. For pickup: retail locations.
	Destinations []map[string]interface{} `json:"destinations,omitempty"`

	// Fulfillment groups for selecting options. Agent sets selected_option_id on
	// groups to choose shipping method.
	Groups []FulfillmentGroupCreateRequest `json:"groups,omitempty"`

	// Line item IDs fulfilled via this method.
	LineItemIds []string `json:"line_item_ids,omitempty"`

	// ID of the selected destination.
	SelectedDestinationID *string `json:"selected_destination_id,omitempty"`

	// Fulfillment method type.
	Type FulfillmentMethodCreateRequestType `json:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type FulfillmentMethodCreateRequestType string

const FulfillmentMethodCreateRequestTypePickup FulfillmentMethodCreateRequestType = "pickup"
const FulfillmentMethodCreateRequestTypeShipping FulfillmentMethodCreateRequestType = "shipping"

// A fulfillment method (shipping or pickup) with destinations and groups.
type FulfillmentMethodResponse struct {
	// Available destinations. For shipping: addresses. For pickup: retail locations.
	Destinations []map[string]interface{} `json:"destinations,omitempty"`

	// Fulfillment groups for selecting options. Agent sets selected_option_id on
	// groups to choose shipping method.
	Groups []FulfillmentGroupResponse `json:"groups,omitempty"`

	// Unique fulfillment method identifier.
	ID string `json:"id"`

	// Line item IDs fulfilled via this method.
	LineItemIds []string `json:"line_item_ids"`

	// ID of the selected destination.
	SelectedDestinationID *string `json:"selected_destination_id,omitempty"`

	// Fulfillment method type.
	Type FulfillmentMethodResponseType `json:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type FulfillmentMethodResponseType string

const FulfillmentMethodResponseTypePickup FulfillmentMethodResponseType = "pickup"
const FulfillmentMethodResponseTypeShipping FulfillmentMethodResponseType = "shipping"

// A fulfillment method (shipping or pickup) with destinations and groups.
type FulfillmentMethodUpdateRequest struct {
	// Available destinations. For shipping: addresses. For pickup: retail locations.
	Destinations []map[string]interface{} `json:"destinations,omitempty"`

	// Fulfillment groups for selecting options. Agent sets selected_option_id on
	// groups to choose shipping method.
	Groups []FulfillmentGroupUpdateRequest `json:"groups,omitempty"`

	// Unique fulfillment method identifier.
	ID string `json:"id"`

	// Line item IDs fulfilled via this method.
	LineItemIds []string `json:"line_item_ids"`

	// ID of the selected destination.
	SelectedDestinationID *string `json:"selected_destination_id,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A fulfillment option within a group (e.g., Standard Shipping $5, Express $15).
type FulfillmentOptionResponse struct {
	// Carrier name (for shipping).
	Carrier *string `json:"carrier,omitempty"`

	// Complete context for buyer decision (e.g., 'Arrives Dec 12-15 via FedEx').
	Description *string `json:"description,omitempty"`

	// Earliest fulfillment date.
	EarliestFulfillmentTime *time.Time `json:"earliest_fulfillment_time,omitempty"`

	// Unique fulfillment option identifier.
	ID string `json:"id"`

	// Latest fulfillment date.
	LatestFulfillmentTime *time.Time `json:"latest_fulfillment_time,omitempty"`

	// Short label (e.g., 'Express Shipping', 'Curbside Pickup').
	Title string `json:"title"`

	// Fulfillment option totals breakdown.
	Totals []TotalResponse `json:"totals"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Container for fulfillment methods and availability.
type FulfillmentRequest struct {
	// Fulfillment methods for cart items.
	Methods []FulfillmentMethodCreateRequest `json:"methods,omitempty"`
}

// Container for fulfillment methods and availability.
type FulfillmentResponse struct {
	// Inventory availability hints.
	AvailableMethods []FulfillmentAvailableMethodResponse `json:"available_methods,omitempty"`

	// Fulfillment methods for cart items.
	Methods []FulfillmentMethodResponse `json:"methods,omitempty"`
}

type ItemCreateRequest struct {
	// Should be recognized by both the Platform, and the Business. For Google it
	// should match the id provided in the "id" field in the product feed.
	ID string `json:"id"`
}

type ItemResponse struct {
	// Should be recognized by both the Platform, and the Business. For Google it
	// should match the id provided in the "id" field in the product feed.
	ID string `json:"id"`

	// Product image URI.
	ImageURL *string `json:"image_url,omitempty"`

	// Unit price in minor (cents) currency units.
	Price int `json:"price"`

	// Product title.
	Title string `json:"title"`
}

type ItemUpdateRequest struct {
	// Should be recognized by both the Platform, and the Business. For Google it
	// should match the id provided in the "id" field in the product feed.
	ID string `json:"id"`
}

// Line item object. Expected to use the currency of the parent object.
type LineItemCreateRequest struct {
	// Item corresponds to the JSON schema field "item".
	Item ItemCreateRequest `json:"item"`

	// Quantity of the item being purchased.
	Quantity int `json:"quantity"`
}

// Line item object. Expected to use the currency of the parent object.
type LineItemResponse struct {
	// ID corresponds to the JSON schema field "id".
	ID string `json:"id"`

	// Item corresponds to the JSON schema field "item".
	Item ItemResponse `json:"item"`

	// Parent line item identifier for any nested structures.
	ParentID *string `json:"parent_id,omitempty"`

	// Quantity of the item being purchased.
	Quantity int `json:"quantity"`

	// Line item totals breakdown.
	Totals []TotalResponse `json:"totals"`
}

// Line item object. Expected to use the currency of the parent object.
type LineItemUpdateRequest struct {
	// ID corresponds to the JSON schema field "id".
	ID *string `json:"id,omitempty"`

	// Item corresponds to the JSON schema field "item".
	Item ItemUpdateRequest `json:"item"`

	// Parent line item identifier for any nested structures.
	ParentID *string `json:"parent_id,omitempty"`

	// Quantity of the item being purchased.
	Quantity int `json:"quantity"`
}

type Link struct {
	// Optional display text for the link. When provided, use this instead of
	// generating from type.
	Title *string `json:"title,omitempty"`

	// Type of link. Well-known values: `privacy_policy`, `terms_of_service`,
	// `refund_policy`, `shipping_policy`, `faq`. Consumers SHOULD handle unknown
	// values gracefully by displaying them using the `title` field or omitting the
	// link.
	Type string `json:"type"`

	// The actual URL pointing to the content to be displayed.
	URL string `json:"url"`
}

// JWS Detached Content signature (RFC 7515 Appendix F) over the checkout response
// body (excluding ap2 field). Format: `<base64url-header>..<base64url-signature>`.
// The header MUST contain 'alg' (ES256/ES384/ES512) and 'kid' claims. The
// signature covers both the header and JCS-canonicalized checkout payload.
type MerchantAuthorization string

// Merchant's fulfillment configuration.
type MerchantFulfillmentConfig struct {
	// Allowed method type combinations.
	AllowsMethodCombinations [][]MerchantFulfillmentConfigAllowsMethodCombinationsElemElem `json:"allows_method_combinations,omitempty"`

	// Permits multiple destinations per method type.
	AllowsMultiDestination *MerchantFulfillmentConfigAllowsMultiDestination `json:"allows_multi_destination,omitempty"`
}

type MerchantFulfillmentConfigAllowsMethodCombinationsElemElem string

const MerchantFulfillmentConfigAllowsMethodCombinationsElemElemPickup MerchantFulfillmentConfigAllowsMethodCombinationsElemElem = "pickup"
const MerchantFulfillmentConfigAllowsMethodCombinationsElemElemShipping MerchantFulfillmentConfigAllowsMethodCombinationsElemElem = "shipping"

// Permits multiple destinations per method type.
type MerchantFulfillmentConfigAllowsMultiDestination struct {
	// Multiple pickup locations allowed.
	Pickup *bool `json:"pickup,omitempty"`

	// Multiple shipping destinations allowed.
	Shipping *bool `json:"shipping,omitempty"`
}

type MessageError struct {
	// Error code. Possible values include: missing, invalid, out_of_stock,
	// payment_declined, requires_sign_in, requires_3ds, requires_identity_linking.
	// Freeform codes also allowed.
	Code string `json:"code"`

	// Human-readable message.
	Content string `json:"content"`

	// Content format, default = plain.
	ContentType MessageErrorContentType `json:"content_type,omitempty"`

	// RFC 9535 JSONPath to the component the message refers to (e.g., $.items[1]).
	Path *string `json:"path,omitempty"`

	// Declares who resolves this error. 'recoverable': agent can fix via API.
	// 'requires_buyer_input': merchant requires information their API doesn't support
	// collecting programmatically (checkout incomplete). 'requires_buyer_review':
	// buyer must authorize before order placement due to policy, regulatory, or
	// entitlement rules (checkout complete). Errors with 'requires_*' severity
	// contribute to 'status: requires_escalation'.
	Severity MessageErrorSeverity `json:"severity"`

	// Message type discriminator.
	Type string `json:"type"`
}

type MessageErrorContentType string

const MessageErrorContentTypeMarkdown MessageErrorContentType = "markdown"
const MessageErrorContentTypePlain MessageErrorContentType = "plain"

type MessageErrorSeverity string

const MessageErrorSeverityRecoverable MessageErrorSeverity = "recoverable"
const MessageErrorSeverityRequiresBuyerInput MessageErrorSeverity = "requires_buyer_input"
const MessageErrorSeverityRequiresBuyerReview MessageErrorSeverity = "requires_buyer_review"

type MessageInfo struct {
	// Info code for programmatic handling.
	Code *string `json:"code,omitempty"`

	// Human-readable message.
	Content string `json:"content"`

	// Content format, default = plain.
	ContentType MessageInfoContentType `json:"content_type,omitempty"`

	// RFC 9535 JSONPath to the component the message refers to.
	Path *string `json:"path,omitempty"`

	// Message type discriminator.
	Type string `json:"type"`
}

type MessageInfoContentType string

const MessageInfoContentTypeMarkdown MessageInfoContentType = "markdown"
const MessageInfoContentTypePlain MessageInfoContentType = "plain"

type MessageWarning struct {
	// Warning code. Machine-readable identifier for the warning type (e.g.,
	// final_sale, prop65, fulfillment_changed, age_restricted, etc.).
	Code string `json:"code"`

	// Human-readable warning message that MUST be displayed.
	Content string `json:"content"`

	// Content format, default = plain.
	ContentType MessageWarningContentType `json:"content_type,omitempty"`

	// JSONPath (RFC 9535) to related field (e.g., $.line_items[0]).
	Path *string `json:"path,omitempty"`

	// Message type discriminator.
	Type string `json:"type"`
}

type MessageWarningContentType string

const MessageWarningContentTypeMarkdown MessageWarningContentType = "markdown"
const MessageWarningContentTypePlain MessageWarningContentType = "plain"

// Order schema with immutable line items, buyer-facing fulfillment expectations,
// and append-only event logs.
type Order struct {
	// Append-only event log of money movements (refunds, returns, credits, disputes,
	// cancellations, etc.) that exist independently of fulfillment.
	Adjustments []Adjustment `json:"adjustments,omitempty"`

	// Associated checkout ID for reconciliation.
	CheckoutID string `json:"checkout_id"`

	// Fulfillment data: buyer expectations and what actually happened.
	Fulfillment OrderFulfillment `json:"fulfillment"`

	// Unique order identifier.
	ID string `json:"id"`

	// Immutable line items â€” source of truth for what was ordered.
	LineItems []OrderLineItem `json:"line_items"`

	// Permalink to access the order on merchant site.
	PermalinkURL string `json:"permalink_url"`

	// Different totals for the order.
	Totals []TotalResponse `json:"totals"`

	// Ucp corresponds to the JSON schema field "ucp".
	Ucp ResponseOrder `json:"ucp"`
}

// Order details available at the time of checkout completion.
type OrderConfirmation struct {
	// Unique order identifier.
	ID string `json:"id"`

	// Permalink to access the order on merchant site.
	PermalinkURL string `json:"permalink_url"`
}

// Fulfillment data: buyer expectations and what actually happened.
type OrderFulfillment struct {
	// Append-only event log of actual shipments. Each event references line items by
	// ID.
	Events []FulfillmentEvent `json:"events,omitempty"`

	// Buyer-facing groups representing when/how items will be delivered. Can be
	// split, merged, or adjusted post-order.
	Expectations []Expectation `json:"expectations,omitempty"`
}

type OrderLineItem struct {
	// Line item identifier.
	ID string `json:"id"`

	// Product data (id, title, price, image_url).
	Item ItemResponse `json:"item"`

	// Parent line item identifier for any nested structures.
	ParentID *string `json:"parent_id,omitempty"`

	// Quantity tracking. Both total and fulfilled are derived from events.
	Quantity OrderLineItemQuantity `json:"quantity"`

	// Derived status: fulfilled if quantity.fulfilled == quantity.total, partial if
	// quantity.fulfilled > 0, otherwise processing.
	Status OrderLineItemStatus `json:"status"`

	// Line item totals breakdown.
	Totals []TotalResponse `json:"totals"`
}

// Quantity tracking. Both total and fulfilled are derived from events.
type OrderLineItemQuantity struct {
	// Quantity fulfilled (sum from fulfillment events).
	Fulfilled int `json:"fulfilled"`

	// Current total quantity.
	Total int `json:"total"`
}

type OrderLineItemStatus string

const OrderLineItemStatusFulfilled OrderLineItemStatus = "fulfilled"
const OrderLineItemStatusPartial OrderLineItemStatus = "partial"
const OrderLineItemStatusProcessing OrderLineItemStatus = "processing"

// Non-sensitive backend identifiers for linking.
type PaymentAccountInfo struct {
	// EMVCo PAR. A unique identifier linking a payment card to a specific account,
	// enabling tracking across tokens (Apple Pay, physical card, etc).
	PaymentAccountReference *string `json:"payment_account_reference,omitempty"`
}

// Payment configuration containing handlers.
type PaymentCreateRequest struct {
	// The payment instruments available for this payment. Each instrument is
	// associated with a specific handler via the handler_id field. Handlers can
	// extend the base payment_instrument schema to add handler-specific fields.
	Instruments []map[string]interface{} `json:"instruments,omitempty"`

	// The id of the currently selected payment instrument from the instruments array.
	// Set by the agent when submitting payment, and echoed back by the merchant in
	// finalized state.
	SelectedInstrumentID *string `json:"selected_instrument_id,omitempty"`
}

// The data that will used to submit payment to the merchant.
type PaymentData struct {
	// PaymentData corresponds to the JSON schema field "payment_data".
	PaymentData map[string]interface{} `json:"payment_data"`
}

type PaymentHandlerResponse struct {
	// A dictionary containing provider-specific configuration details, such as
	// merchant IDs, supported networks, or gateway credentials.
	Config map[string]interface{} `json:"config"`

	// A URI pointing to a JSON Schema used to validate the structure of the config
	// object.
	ConfigSchema string `json:"config_schema"`

	// The unique identifier for this handler instance within the payment.handlers.
	// Used by payment instruments to reference which handler produced them.
	ID string `json:"id"`

	// InstrumentSchemas corresponds to the JSON schema field "instrument_schemas".
	InstrumentSchemas []string `json:"instrument_schemas"`

	// The specification name using reverse-DNS format. For example,
	// dev.ucp.delegate_payment.
	Name string `json:"name"`

	// A URI pointing to the technical specification or schema that defines how this
	// handler operates.
	Spec string `json:"spec"`

	// Handler version in YYYY-MM-DD format.
	Version Version `json:"version"`
}

// Identity of a participant for token binding. The access_token uniquely
// identifies the participant who tokens should be bound to.
type PaymentIdentity struct {
	// Unique identifier for this participant, obtained during onboarding with the
	// tokenizer.
	AccessToken string `json:"access_token"`
}

// The base definition for any payment instrument. It links the instrument to a
// specific Merchant configuration (handler_id) and defines common fields like
// billing address.
type PaymentInstrumentBase struct {
	// The billing address associated with this payment method.
	BillingAddress *PostalAddress `json:"billing_address,omitempty"`

	// Credential corresponds to the JSON schema field "credential".
	Credential map[string]interface{} `json:"credential,omitempty"`

	// The unique identifier for the handler instance that produced this instrument.
	// This corresponds to the 'id' field in the Payment Handler definition.
	HandlerID string `json:"handler_id"`

	// A unique identifier for this instrument instance, assigned by the Agent. Used
	// to reference this specific instrument in the 'payment.selected_instrument_id'
	// field.
	ID string `json:"id"`

	// The broad category of the instrument (e.g., 'card', 'tokenized_card'). Specific
	// schemas will constrain this to a constant value.
	Type string `json:"type"`
}

// Payment configuration containing handlers.
type PaymentResponse struct {
	// Processing configurations that define how payment instruments can be collected.
	// Each handler specifies a tokenization or payment collection strategy.
	Handlers []PaymentHandlerResponse `json:"handlers"`

	// The payment instruments available for this payment. Each instrument is
	// associated with a specific handler via the handler_id field. Handlers can
	// extend the base payment_instrument schema to add handler-specific fields.
	Instruments []map[string]interface{} `json:"instruments,omitempty"`

	// The id of the currently selected payment instrument from the instruments array.
	// Set by the agent when submitting payment, and echoed back by the merchant in
	// finalized state.
	SelectedInstrumentID *string `json:"selected_instrument_id,omitempty"`
}

// Payment configuration containing handlers.
type PaymentUpdateRequest struct {
	// The payment instruments available for this payment. Each instrument is
	// associated with a specific handler via the handler_id field. Handlers can
	// extend the base payment_instrument schema to add handler-specific fields.
	Instruments []map[string]interface{} `json:"instruments,omitempty"`

	// The id of the currently selected payment instrument from the instruments array.
	// Set by the agent when submitting payment, and echoed back by the merchant in
	// finalized state.
	SelectedInstrumentID *string `json:"selected_instrument_id,omitempty"`
}

// Platform's order capability configuration.
type PlatformConfig struct {
	// URL where merchant sends order lifecycle events (webhooks).
	WebhookURL string `json:"webhook_url"`
}

// Platform's fulfillment configuration.
type PlatformFulfillmentConfig struct {
	// Enables multiple groups per method.
	SupportsMultiGroup bool `json:"supports_multi_group,omitempty"`
}

type PostalAddress struct {
	// The country. Recommended to be in 2-letter ISO 3166-1 alpha-2 format, for
	// example "US". For backward compatibility, a 3-letter ISO 3166-1 alpha-3 country
	// code such as "SGP" or a full country name such as "Singapore" can also be used.
	AddressCountry *string `json:"address_country,omitempty"`

	// The locality in which the street address is, and which is in the region. For
	// example, Mountain View.
	AddressLocality *string `json:"address_locality,omitempty"`

	// The region in which the locality is, and which is in the country. Required for
	// applicable countries (i.e. state in US, province in CA). For example,
	// California or another appropriate first-level Administrative division.
	AddressRegion *string `json:"address_region,omitempty"`

	// An address extension such as an apartment number, C/O or alternative name.
	ExtendedAddress *string `json:"extended_address,omitempty"`

	// Optional. First name of the contact associated with the address.
	FirstName *string `json:"first_name,omitempty"`

	// Optional. Full name of the contact associated with the address (if first_name
	// or last_name fields are present they take precedence).
	FullName *string `json:"full_name,omitempty"`

	// Optional. Last name of the contact associated with the address.
	LastName *string `json:"last_name,omitempty"`

	// Optional. Phone number of the contact associated with the address.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// The postal code. For example, 94043.
	PostalCode *string `json:"postal_code,omitempty"`

	// The street address.
	StreetAddress *string `json:"street_address,omitempty"`
}

// Capability reference in responses. Only name/version required to confirm active
// capabilities.
type Response interface{}

// UCP metadata for checkout responses.
type ResponseCheckout struct {
	// Active capabilities for this response.
	Capabilities []ResponseCheckoutCapabilitiesElem `json:"capabilities"`

	// Version corresponds to the JSON schema field "version".
	Version Version `json:"version"`
}

type ResponseCheckoutCapabilitiesElem interface{}

// UCP metadata for order responses. No payment handlers needed post-purchase.
type ResponseOrder struct {
	// Active capabilities for this response.
	Capabilities []ResponseOrderCapabilitiesElem `json:"capabilities"`

	// Version corresponds to the JSON schema field "version".
	Version Version `json:"version"`
}

type ResponseOrderCapabilitiesElem interface{}

// A pickup location (retail store, locker, etc.).
type RetailLocationRequest struct {
	// Physical address of the location.
	Address *PostalAddress `json:"address,omitempty"`

	// Location name (e.g., store name).
	Name string `json:"name"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A pickup location (retail store, locker, etc.).
type RetailLocationResponse struct {
	// Physical address of the location.
	Address *PostalAddress `json:"address,omitempty"`

	// Unique location identifier.
	ID string `json:"id"`

	// Location name (e.g., store name).
	Name string `json:"name"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type ShippingDestinationRequest struct {
	// The country. Recommended to be in 2-letter ISO 3166-1 alpha-2 format, for
	// example "US". For backward compatibility, a 3-letter ISO 3166-1 alpha-3 country
	// code such as "SGP" or a full country name such as "Singapore" can also be used.
	AddressCountry *string `json:"address_country,omitempty"`

	// The locality in which the street address is, and which is in the region. For
	// example, Mountain View.
	AddressLocality *string `json:"address_locality,omitempty"`

	// The region in which the locality is, and which is in the country. Required for
	// applicable countries (i.e. state in US, province in CA). For example,
	// California or another appropriate first-level Administrative division.
	AddressRegion *string `json:"address_region,omitempty"`

	// An address extension such as an apartment number, C/O or alternative name.
	ExtendedAddress *string `json:"extended_address,omitempty"`

	// Optional. First name of the contact associated with the address.
	FirstName *string `json:"first_name,omitempty"`

	// Optional. Full name of the contact associated with the address (if first_name
	// or last_name fields are present they take precedence).
	FullName *string `json:"full_name,omitempty"`

	// ID specific to this shipping destination.
	ID *string `json:"id,omitempty"`

	// Optional. Last name of the contact associated with the address.
	LastName *string `json:"last_name,omitempty"`

	// Optional. Phone number of the contact associated with the address.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// The postal code. For example, 94043.
	PostalCode *string `json:"postal_code,omitempty"`

	// The street address.
	StreetAddress *string `json:"street_address,omitempty"`
}

type ShippingDestinationResponse struct {
	// The country. Recommended to be in 2-letter ISO 3166-1 alpha-2 format, for
	// example "US". For backward compatibility, a 3-letter ISO 3166-1 alpha-3 country
	// code such as "SGP" or a full country name such as "Singapore" can also be used.
	AddressCountry *string `json:"address_country,omitempty"`

	// The locality in which the street address is, and which is in the region. For
	// example, Mountain View.
	AddressLocality *string `json:"address_locality,omitempty"`

	// The region in which the locality is, and which is in the country. Required for
	// applicable countries (i.e. state in US, province in CA). For example,
	// California or another appropriate first-level Administrative division.
	AddressRegion *string `json:"address_region,omitempty"`

	// An address extension such as an apartment number, C/O or alternative name.
	ExtendedAddress *string `json:"extended_address,omitempty"`

	// Optional. First name of the contact associated with the address.
	FirstName *string `json:"first_name,omitempty"`

	// Optional. Full name of the contact associated with the address (if first_name
	// or last_name fields are present they take precedence).
	FullName *string `json:"full_name,omitempty"`

	// ID specific to this shipping destination.
	ID string `json:"id"`

	// Optional. Last name of the contact associated with the address.
	LastName *string `json:"last_name,omitempty"`

	// Optional. Phone number of the contact associated with the address.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// The postal code. For example, 94043.
	PostalCode *string `json:"postal_code,omitempty"`

	// The street address.
	StreetAddress *string `json:"street_address,omitempty"`
}

// Base token credential schema. Concrete payment handlers may extend this schema
// with additional fields and define their own constraints.
type TokenCredentialCreateRequest struct {
	// The token value.
	Token string `json:"token"`

	// The specific type of token produced by the handler (e.g., 'stripe_token').
	Type string `json:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Base token credential schema. Concrete payment handlers may extend this schema
// with additional fields and define their own constraints.
type TokenCredentialResponse struct {
	// The specific type of token produced by the handler (e.g., 'stripe_token').
	Type string `json:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Base token credential schema. Concrete payment handlers may extend this schema
// with additional fields and define their own constraints.
type TokenCredentialUpdateRequest struct {
	// The token value.
	Token string `json:"token"`

	// The specific type of token produced by the handler (e.g., 'stripe_token').
	Type string `json:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type TotalResponse struct {
	// If type == total, sums subtotal - discount + fulfillment + tax + fee. Should be
	// >= 0. Amount in minor (cents) currency units.
	Amount int `json:"amount"`

	// Text to display against the amount. Should reflect appropriate method (e.g.,
	// 'Shipping', 'Delivery').
	DisplayText *string `json:"display_text,omitempty"`

	// Type of total categorization.
	Type TotalResponseType `json:"type"`
}

type TotalResponseType string

const TotalResponseTypeDiscount TotalResponseType = "discount"
const TotalResponseTypeFee TotalResponseType = "fee"
const TotalResponseTypeFulfillment TotalResponseType = "fulfillment"
const TotalResponseTypeItemsDiscount TotalResponseType = "items_discount"
const TotalResponseTypeSubtotal TotalResponseType = "subtotal"
const TotalResponseTypeTax TotalResponseType = "tax"
const TotalResponseTypeTotal TotalResponseType = "total"

// Schema for UCP service definitions. A service defines the API surface for a
// vertical (shopping, common, etc.) with transport bindings.
type UCPService struct {
	// A2A transport binding
	A2A *UCPServiceA2A `json:"a2a,omitempty"`

	// Embedded transport binding (JSON-RPC 2.0 over postMessage). Unlike REST/MCP,
	// the endpoint is per-capability (i.e. per-checkout via continue_url), not
	// per-service.
	Embedded *UCPServiceEmbedded `json:"embedded,omitempty"`

	// MCP transport binding
	Mcp *UCPServiceMcp `json:"mcp,omitempty"`

	// REST transport binding
	Rest *UCPServiceRest `json:"rest,omitempty"`

	// URL to service documentation. Origin MUST match namespace authority.
	Spec string `json:"spec"`

	// Service version in YYYY-MM-DD format.
	Version Version `json:"version"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A2A transport binding
type UCPServiceA2A struct {
	// Merchant's Agent Card endpoint
	Endpoint string `json:"endpoint"`
}

// Embedded transport binding (JSON-RPC 2.0 over postMessage). Unlike REST/MCP, the
// endpoint is per-capability (i.e. per-checkout via continue_url), not
// per-service.
type UCPServiceEmbedded struct {
	// URL to OpenRPC specification (JSON format) defining the embedded protocol
	Schema string `json:"schema"`
}

// MCP transport binding
type UCPServiceMcp struct {
	// Merchant's MCP endpoint
	Endpoint string `json:"endpoint"`

	// URL to OpenRPC specification (JSON format)
	Schema string `json:"schema"`
}

// REST transport binding
type UCPServiceRest struct {
	// Merchant's REST API endpoint
	Endpoint string `json:"endpoint"`

	// URL to OpenAPI 3.x specification (JSON format)
	Schema string `json:"schema"`
}

// UCP protocol version in YYYY-MM-DD format.
type Version string
